---
name: db-backfill-plan
description: "既存データの修正・補完を段階的に実行する計画を策定する"
argument-hint: "対象テーブル名 or バックフィル要件の説明"
user-invocable: true
disable-model-invocation: true
allowed-tools: Read, Grep, Glob
---

あなたは慎重なシニアエンジニア。$ARGUMENTS を対象に以下を実行せよ。

## 実行モード

- **簡易モード**（デフォルト）: 手順2（戦略決定）、3（SQL設計）、4（ロールバック計画）のみ実行し、簡潔な実行計画を返す
- **詳細モード**: `--detailed` を引数に追加すると、全6手順を実行し包括的な出力を返す

$ARGUMENTS に `--detailed` が含まれていない場合は簡易モードで実行する。簡易モードでは出力フォーマットの該当セクションのみ出力する。

## 目的

既存データの修正・補完（バックフィル）を安全に実行するための段階的実行計画を策定する。大量データの更新によるサービス影響を最小限に抑え、ロールバック可能な手順を含む包括的な実行計画を作成する。

## 入力

- 対象テーブル名と修正・補完の要件
- 現在のスキーマ定義
- 関連するマイグレーションファイル（カラム追加等に伴うバックフィルの場合）
- 対象データの条件と推定件数
- ビジネスルール・変換ロジックの仕様

## 手順

### 1. 現状分析

1-1. 対象テーブルの現在のスキーマ定義を確認する
1-2. バックフィル対象カラムの現在のデータ分布を分析するクエリを準備する
1-3. 対象レコードの推定件数と選定条件を明確化する
1-4. 関連テーブルへの影響（外部キー、トリガー、ビュー）を洗い出す
1-5. バックフィルの元データ（変換元）の所在と信頼性を確認する
1-6. 既存アプリケーションコードでの該当カラム参照箇所を特定する

### 2. バックフィル戦略の決定

2-1. バッチサイズを決定する（1000-10000件/バッチが目安）
2-2. 実行方式を選定する:
  - **オンラインバックフィル**: サービス稼働中に段階実行
  - **メンテナンスウィンドウ**: サービス停止期間中に一括実行
  - **バックグラウンドジョブ**: 非同期ワーカーで段階実行
2-3. スロットリング（実行間隔）を設定する（レプリカ遅延考慮）
2-4. 並列度を決定する（テーブルロックを避ける範囲で）
2-5. 実行時間の見積もりを算出する

### 3. バックフィルSQL の設計

3-1. UPDATE 文を設計する（バッチ範囲指定付き）
3-2. データ変換ロジックを SQL で記述する
3-3. 進捗追跡用の仕組みを設計する（処理済みID範囲の記録）
3-4. エラーハンドリング戦略を設計する:
  - 個別レコードエラー時の処理（スキップ or 中断）
  - デッドロック発生時のリトライ戦略
  - タイムアウト時の再開手順
3-5. 検証クエリ（各バッチ完了後のデータ整合性確認）を設計する

### 4. ロールバック計画

4-1. バックフィル前のデータバックアップ方法を策定する:
  - バックアップテーブルの作成（`_backup_YYYYMMDD` サフィックス）
  - 対象カラムの旧値を保持する方法
4-2. ロールバック SQL を設計する（バックアップテーブルからの復元）
4-3. 部分ロールバック（特定バッチのみ取消し）の手順を策定する
4-4. ロールバック判断基準を定義する:
  - エラー率の閾値
  - パフォーマンス劣化の閾値
  - データ不整合の検出基準

### 5. 実行計画の作成

5-1. 事前準備チェックリストを作成する
5-2. 段階的実行のステップを定義する:
  - Step 0: バックアップ取得
  - Step 1: 少量テスト実行（10-100件）
  - Step 2: 中規模テスト実行（1000件）
  - Step 3: 本番バッチ実行（全件を分割）
  - Step 4: 検証・完了確認
5-3. 各ステップの成功基準を定義する
5-4. モニタリング項目を定義する（レプリカ遅延、CPU使用率、ロック待ち）
5-5. 緊急停止手順を策定する
5-6. 実行後のクリーンアップ手順を策定する（バックアップテーブル削除等）

### 6. アプリケーション連携

6-1. バックフィル中のアプリケーション動作への影響を分析する
6-2. 新旧データが混在する過渡期の処理方針を策定する
6-3. バックフィル完了後のアプリケーション側の変更を特定する（NOT NULL制約追加等）
6-4. フィーチャーフラグとの連携が必要な場合の手順を策定する

## 出力フォーマット

```markdown
# バックフィル計画: [対象テーブル].[対象カラム]

## 概要
| 項目 | 内容 |
|------|------|
| 対象テーブル | `table_name` |
| 対象カラム | `column_name` |
| バックフィル理由 | [カラム追加に伴うデフォルト値設定 / データ修正 / 正規化 等] |
| 推定対象件数 | 約 N 件 |
| 推定実行時間 | 約 N 時間 |
| 実行方式 | オンライン / メンテナンスウィンドウ / バックグラウンド |
| サービス影響 | あり（軽微） / なし |

## データ分析クエリ
```sql
-- 現状のデータ分布を確認する
SELECT column_name, COUNT(*) FROM table_name GROUP BY column_name;

-- バックフィル対象件数を確認する
SELECT COUNT(*) FROM table_name WHERE column_name IS NULL;
```

## バックアップ手順
```sql
-- バックアップテーブルの作成
CREATE TABLE table_name_backup_20240601 AS
SELECT id, column_name FROM table_name WHERE column_name IS NULL;

-- バックアップ件数の確認
SELECT COUNT(*) FROM table_name_backup_20240601;
```

## バックフィル SQL

### Step 1: テスト実行（10件）
```sql
UPDATE table_name
SET column_name = [変換ロジック]
WHERE column_name IS NULL
  AND id IN (SELECT id FROM table_name WHERE column_name IS NULL LIMIT 10);

-- 検証
SELECT * FROM table_name WHERE id IN (...);
```

### Step 2: 中規模テスト（1000件）
```sql
UPDATE table_name
SET column_name = [変換ロジック],
    updated_at = NOW()
WHERE column_name IS NULL
  AND id BETWEEN :start_id AND :end_id
LIMIT 1000;
```

### Step 3: 本番バッチ実行
```sql
-- バッチ処理ループ（疑似コード）
-- batch_size = 5000
-- sleep_interval = 2 seconds (レプリカ遅延を考慮)

UPDATE table_name
SET column_name = [変換ロジック],
    updated_at = NOW()
WHERE column_name IS NULL
  AND id > :last_processed_id
ORDER BY id
LIMIT :batch_size;

-- 進捗記録
INSERT INTO backfill_progress (table_name, last_id, batch_count, updated_at)
VALUES ('table_name', :last_processed_id, :batch_num, NOW())
ON CONFLICT (table_name) DO UPDATE
SET last_id = EXCLUDED.last_id, batch_count = EXCLUDED.batch_count;
```

## ロールバック SQL
```sql
-- バックアップテーブルから復元
UPDATE table_name t
JOIN table_name_backup_20240601 b ON t.id = b.id
SET t.column_name = b.column_name;
```

## モニタリング項目
| 項目 | 正常範囲 | 警告閾値 | 停止閾値 |
|------|---------|---------|---------|
| レプリカ遅延 | < 1秒 | > 5秒 | > 30秒 |
| CPU使用率 | < 50% | > 70% | > 90% |
| ロック待ちスレッド | 0 | > 5 | > 20 |
| バッチ処理時間 | < 10秒/バッチ | > 30秒 | > 60秒 |
| エラー率 | 0% | > 0.1% | > 1% |

## 実行チェックリスト

### 事前準備
- [ ] バックアップテーブルが作成済みであること
- [ ] バックアップ件数が対象件数と一致すること
- [ ] テスト環境で同一手順を実行済みであること
- [ ] レプリカ遅延が 0 秒であること
- [ ] モニタリングダッシュボードを開いていること
- [ ] ロールバック SQL をすぐ実行できる状態であること

### 実行中
- [ ] 各バッチ完了後にレプリカ遅延を確認する
- [ ] エラー発生時は即座に停止し原因を調査する
- [ ] 進捗を記録する（処理済みID範囲）

### 実行後
- [ ] 全対象レコードが更新されたことを確認する
- [ ] データ整合性チェッククエリを実行する
- [ ] アプリケーションの動作確認を行う
- [ ] バックアップテーブルの保持期間を決定する（推奨: 7日間）
- [ ] 関連するマイグレーション（NOT NULL制約追加等）の実行タイミングを確認する

## 緊急停止手順
1. バッチ処理を即座に停止する
2. 現在実行中のトランザクションの完了を待つ
3. 進捗記録から最後に処理されたIDを確認する
4. 必要に応じてロールバック SQL を実行する
5. 原因を調査し、計画を修正する

## 過渡期のアプリケーション対応
| フェーズ | column_name の状態 | アプリケーション対応 |
|---------|-------------------|-------------------|
| バックフィル前 | NULL あり | NULL を許容するコード |
| バックフィル中 | NULL と非NULL混在 | NULL を許容するコード（変更なし） |
| バックフィル後 | 全て非NULL | NOT NULL 制約追加 → コード側NULLチェック除去 |
```

## 安全注意

- **絶対に実際の SQL を実行しないこと** -- 本スキルは計画策定のみを行う
- **本番データベースへの接続を行わないこと**
- **バックフィル SQL はあくまで計画書としての記述であり、直接実行しないこと**
- **バックアップなしのバックフィルを絶対に計画しないこと**
- **大量 UPDATE はテーブルロックを引き起こす可能性があるため、必ずバッチ分割を計画すること**
- **レプリカ遅延を考慮したスロットリングを必ず含めること**
- **ロールバック不可能なデータ変換（情報の不可逆的な喪失）は特に警告すること**
- **本番データの具体的な値を計画書に記載しないこと** -- プレースホルダを使用する

## 終了条件

- 対象データの条件と推定件数が明確化されていること
- バッチサイズとスロットリング設定が決定されていること
- バックアップ手順が策定されていること
- バックフィル SQL がバッチ処理形式で設計されていること
- ロールバック SQL と判断基準が策定されていること
- 段階的実行ステップ（テスト→中規模→本番）が定義されていること
- モニタリング項目と閾値が定義されていること
- 実行前・中・後のチェックリストが作成されていること
- 緊急停止手順が策定されていること
- アプリケーション側の過渡期対応が分析されていること

## このスキルが向かないケース

- **1000万件超の大規模バックフィル**: 出力された計画はあくまで叩き台。大規模データの場合は DBA と協議し、負荷テスト環境で検証してから本番実行すること
- **リアルタイム性が求められるテーブル**: 書き込み頻度が高いテーブルのバックフィルは、ロック競合やレプリカ遅延の実測が必須。計画だけで安全性を判断しないこと
