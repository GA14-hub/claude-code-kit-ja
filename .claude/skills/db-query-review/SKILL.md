---
name: db-query-review
description: "N+1問題・フルスキャン・集約負荷などクエリのパフォーマンス問題をレビューする"
argument-hint: "クエリファイルパス or アプリケーションコードパス"
user-invocable: true
disable-model-invocation: true
allowed-tools: Read, Grep, Glob
---

あなたは慎重なシニアエンジニア。$ARGUMENTS を対象に以下を実行せよ。

## 目的

アプリケーションコードおよび SQL クエリを分析し、N+1 問題、フルテーブルスキャン、不適切な集約処理、非効率な結合パターンなどのパフォーマンス問題を検出する。各問題に対して具体的な改善案を提示する。

## 入力

- アプリケーションコード（Repository / DAO / Model / Controller 層）
- 生 SQL クエリファイル
- ORM クエリビルダーコード
- スロークエリログ（任意）
- EXPLAIN 出力結果（任意）

## 手順

### 1. クエリパターンの収集

1-1. 指定パスのコードから SQL クエリ・ORM クエリを抽出する
1-2. ループ内でのクエリ実行パターンを検出する
1-3. ORM のリレーション読み込み方法（Eager / Lazy）を特定する
1-4. 動的に構築されるクエリ（文字列結合・条件分岐）を把握する
1-5. トランザクション境界とクエリの関係を確認する

### 2. N+1 問題の検出

2-1. ループ内で繰り返し実行されるクエリパターンを特定する
2-2. ORM の Lazy Loading によるN+1を検出する（belongs_to, has_many 等）
2-3. ネストしたリレーションアクセスによる多段N+1を検出する
2-4. 各N+1パターンの推定クエリ発行数を計算する
2-5. Eager Loading / JOIN / サブクエリへの書き換え案を作成する

### 3. フルテーブルスキャンの検出

3-1. WHERE 句のない SELECT 文を検出する
3-2. インデックス未使用の条件式を特定する（関数適用、型変換、LIKE '%prefix' 等）
3-3. OR 条件によるインデックス無効化パターンを検出する
3-4. 暗黙的な型変換によるインデックス無効化を検出する
3-5. SELECT * の使用箇所を特定し、必要列のみの選択を推奨する

### 4. 集約・ソート処理の評価

4-1. 大量データに対する COUNT / SUM / AVG 等の集約処理を検出する
4-2. GROUP BY 句のインデックス活用可能性を評価する
4-3. ORDER BY 句によるファイルソート（filesort）発生の可能性を検出する
4-4. DISTINCT の不要な使用を検出する
4-5. HAVING 句を WHERE 句に移動可能なケースを特定する
4-6. ウィンドウ関数の適切性を評価する

### 5. 結合パターンの評価

5-1. 不要な JOIN（結合結果を使用していない）を検出する
5-2. 結合条件のインデックス有無を確認する
5-3. 大量テーブル同士の CROSS JOIN / 直積結合を検出する
5-4. サブクエリの JOIN 書き換え可能性を評価する
5-5. 相関サブクエリのパフォーマンス影響を評価する

### 6. 総合評価と改善案

6-1. 各検出項目の影響度をスコアリングする（CRITICAL / HIGH / MEDIUM / LOW）
6-2. 改善の優先順位を決定する（影響度 x 実行頻度）
6-3. 各問題に対する具体的な改善 SQL / コードを記述する
6-4. 改善効果の定性的な見積もりを提示する

## 出力フォーマット

```markdown
# クエリレビュー: [対象ファイル / モジュール名]

## レビューサマリ
| 項目 | 件数 |
|------|------|
| 分析クエリ数 | N 件 |
| N+1 問題 | N 件 |
| フルスキャン | N 件 |
| 集約負荷 | N 件 |
| 結合問題 | N 件 |
| 総合リスク | CRITICAL / HIGH / MEDIUM / LOW |

## 検出詳細

### [CRITICAL] N+1 問題: [概要]
- **箇所**: `file_path:line`
- **問題コード**:
```python
# 例: ループ内でクエリが発行される
for user in users:
    orders = db.query(Order).filter(Order.user_id == user.id).all()  # N回実行
```
- **推定発行数**: 親レコード N 件 x 子クエリ 1 回 = N+1 回
- **改善案**:
```python
# Eager Loading による解決
users = db.query(User).options(joinedload(User.orders)).all()
```
- **期待効果**: N+1 回 → 1-2 回に削減

### [HIGH] フルテーブルスキャン: [概要]
- **箇所**: `file_path:line`
- **問題クエリ**:
```sql
SELECT * FROM orders WHERE YEAR(created_at) = 2024;  -- 関数適用でインデックス無効
```
- **改善案**:
```sql
SELECT order_id, user_id, total FROM orders
WHERE created_at >= '2024-01-01' AND created_at < '2025-01-01';  -- 範囲条件に変換
```
- **根拠**: 関数適用を排除しインデックスレンジスキャンを可能にする

### [MEDIUM] 不要な集約処理: [概要]
- **箇所**: `file_path:line`
- **問題点**: [具体的な説明]
- **改善案**: [改善コード]

## 改善優先度マトリクス
| 優先度 | 問題 | 影響度 | 実行頻度 | 改善コスト |
|--------|------|--------|---------|-----------|
| 1 | [N+1問題A] | CRITICAL | 高 | 低 |
| 2 | [フルスキャンB] | HIGH | 中 | 中 |
| 3 | [集約負荷C] | MEDIUM | 低 | 高 |

## アンチパターン一覧
| パターン | 検出数 | ファイル |
|----------|--------|---------|
| SELECT * | N 箇所 | `file1.py`, `file2.py` |
| ループ内クエリ | N 箇所 | `file3.py` |
| 暗黙的型変換 | N 箇所 | `file4.py` |

## 推奨アクション
- [ ] [最優先で修正すべき項目]
- [ ] [次に対応すべき項目]
- [ ] [中長期的に改善すべき項目]
```

## 安全注意

- **絶対に実際の SQL を実行しないこと** -- 本スキルは静的解析のみを行う
- **本番データベースへの接続を行わないこと**
- **アプリケーションコードを変更しないこと** -- レビュー結果の報告のみ
- **ORM 固有の挙動を正確に理解した上で分析すること**（ActiveRecord, SQLAlchemy, Eloquent, Prisma 等）
- **パフォーマンス影響の見積もりは定性的に留めること** -- 正確な数値は実測が必要
- **クエリにユーザ入力が直接埋め込まれている場合、SQLインジェクションリスクも併せて警告すること**
- **推測に基づく判断は明示的に「推定」と記述すること**

## 終了条件

- 対象範囲のクエリパターンがすべて収集・分析されていること
- N+1 問題が網羅的に検出されていること
- フルテーブルスキャンの原因が特定されていること
- 各問題に具体的な改善コードが提示されていること
- 改善の優先順位がマトリクスで整理されていること
- 推奨アクションリストが作成されていること

## このスキルが向かないケース

- **実行計画（EXPLAIN）の代替**: コードベースの静的分析のみ。実際のデータ分布・インデックス使用状況は `EXPLAIN ANALYZE` で確認が必要
- **ストアドプロシージャやビュー内の複雑なクエリ**: ファイル内の SQL パターンが主な対象。DB 側に定義されたロジックの分析には向かない
