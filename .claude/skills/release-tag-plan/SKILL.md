---
name: release-tag-plan
description: リリースタグ・セマンティックバージョニング・CHANGELOG 戦略を策定する。
argument-hint: "[project-dir] (任意でリリース種別: major/minor/patch)"
user-invocable: true
disable-model-invocation: true
allowed-tools: Read, Grep, Glob, Bash(git log *), Bash(git tag *)
---

あなたは慎重なシニアエンジニア。$ARGUMENTS を対象に以下を実行せよ。

## 目的

プロジェクトの既存のバージョニング体系とリリース履歴を分析し、セマンティックバージョニング（SemVer）に基づいたタグ戦略・CHANGELOG 自動生成・リリースワークフローを策定する。既存の慣行を尊重しつつ、一貫性と自動化可能性を高める。

## 入力

- プロジェクトディレクトリ（必須）
- 任意: 次回リリースの種別（major / minor / patch）
- 任意: リリースサイクル（週次、隔週、スプリント単位等）
- 任意: モノレポかシングルリポかの情報
- 不足している場合はユーザーに質問する

## 手順

1. **現状のバージョニング分析**
   - `git tag --list` で既存のタグ一覧を取得し、命名パターンを分析する
   - `git log --oneline` で直近のコミット履歴を確認し、コミットメッセージの慣行を把握する
   - `package.json`、`pyproject.toml`、`go.mod` 等のバージョンフィールドを Read で確認する
   - 既存の CHANGELOG.md があれば Read で構造とスタイルを把握する
   - リリースブランチの有無（release/*、main、develop 等）を確認する

2. **コミット履歴の分類**
   - 最新タグから HEAD までのコミットを `git log` で取得する
   - 各コミットを Conventional Commits の観点で分類する:
     - **feat**: 新機能追加（→ minor バージョンアップ）
     - **fix**: バグ修正（→ patch バージョンアップ）
     - **BREAKING CHANGE**: 破壊的変更（→ major バージョンアップ）
     - **docs / chore / refactor / test**: バージョンに影響しない変更
   - Conventional Commits に従っていない場合、コミット内容から推定して分類する

3. **次回バージョンの提案**
   - コミット分類の結果に基づき、SemVer に従った次回バージョンを提案する
   - 破壊的変更がある場合は明確に警告し、移行ガイドの必要性を指摘する
   - プレリリース版（alpha、beta、rc）の必要性を検討する
   - 0.x.y 系（初期開発フェーズ）の場合の SemVer ルールの違いを説明する

4. **CHANGELOG 戦略の設計**
   - CHANGELOG のフォーマットを設計する（Keep a Changelog 形式を推奨）
   - 自動生成ツールの選定と設定を提案する:
     - conventional-changelog / standard-version / release-please
     - semantic-release / goreleaser
   - CHANGELOG に含める情報と除外する情報の基準を策定する
   - 手動記載が必要な項目（移行手順、重要な注意事項）のガイドラインを作成する

5. **タグ・リリースワークフローの策定**
   - タグの命名規則を定義する（`v1.2.3`、`1.2.3`、プレフィックス有無）
   - リリースフロー（誰が、いつ、どの手順でリリースするか）を設計する:
     - ブランチ戦略との連携（main マージ → 自動タグ、手動タグ切り）
     - GitHub Releases との連携（リリースノートの自動生成）
     - NPM / PyPI / Docker Hub 等へのパッケージ公開の自動化
   - モノレポの場合、パッケージごとの独立バージョニング戦略を設計する

6. **Conventional Commits 導入支援**
   - 現在 Conventional Commits を使っていない場合、導入計画を提案する
   - commitlint の設定テンプレートを提供する
   - Git フック（husky / pre-commit）によるコミットメッセージ検証の設定を提案する

## 出力フォーマット

```markdown
## 現状分析

- **既存タグ**: [タグの数と命名パターン（例: v1.0.0 形式、23個）]
- **最新タグ**: [最新のタグ名とその日時]
- **コミット規約**: [Conventional Commits 準拠 / 非準拠 / 部分的]
- **既存 CHANGELOG**: [あり（形式の概要）/ なし]
- **バージョン管理ファイル**: [package.json 等のバージョン値]

## コミット分類（最新タグ以降）

| 種別 | 件数 | 代表的なコミット |
|------|------|----------------|
| feat | [N件] | [コミットメッセージ例] |
| fix | [N件] | [コミットメッセージ例] |
| BREAKING | [N件] | [コミットメッセージ例] |
| その他 | [N件] | [docs/chore/refactor 等] |

## 次回バージョン提案

- **推奨バージョン**: [X.Y.Z]
- **根拠**: [バージョンアップの理由]
- **破壊的変更**: [あり（内容）/ なし]

## CHANGELOG ドラフト

[次回リリースの CHANGELOG をコードブロックで出力]

## タグ戦略

- **命名規則**: [v{major}.{minor}.{patch}]
- **プレリリース**: [{version}-beta.{N} の使い方]
- **タグ作成方法**: [手動 / CI 自動 / release-please]

## リリースワークフロー

1. [リリース手順1]
2. [リリース手順2]
3. [リリース手順3]

## 自動化設定

### 推奨ツール

- **CHANGELOG 生成**: [ツール名と理由]
- **コミット検証**: [commitlint の設定例]
- **リリース自動化**: [GitHub Actions のワークフロー概要]

### 設定ファイル

[必要な設定ファイルの内容をコードブロックで出力]

## 導入ステップ

| ステップ | 内容 | 優先度 |
|---------|------|-------|
| 1 | [最初にやること] | 必須 |
| 2 | [次にやること] | 推奨 |
| 3 | [余裕があればやること] | 任意 |
```

## 安全注意

- `git tag` の作成・削除・push は行わず、提案のみ行う
- 既存のタグやリリース履歴を変更・削除する操作は実行しない
- `git log` と `git tag` の読み取り系コマンドのみ使用する
- リリースに含まれるセキュリティ修正は CHANGELOG に記載し、詳細な脆弱性情報は含めない
- 本番環境へのデプロイを伴うリリース手順には明確な承認ステップを含める

## 終了条件

上記の出力フォーマットに従ったリリース戦略書を出力したら停止する。現状分析、次回バージョン提案、CHANGELOG ドラフト、タグ戦略、リリースワークフロー、自動化設定が含まれていること。タグの作成やリリース実行はユーザーの指示を待つ。

## このスキルが向かないケース

- **モノレポの複数パッケージ同時リリース**: 単一プロジェクトのリリース計画が主な対象。モノレポでのパッケージ間依存やリリース順序の調整は別途設計が必要
- **既にリリース自動化が成熟しているプロジェクト**: semantic-release 等が導入済みの場合、このスキルの出力と競合する可能性がある
