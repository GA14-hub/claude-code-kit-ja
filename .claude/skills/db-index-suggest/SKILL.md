---
name: db-index-suggest
description: "クエリと実行計画を分析しインデックス追加・改善を提案する"
argument-hint: "SQLクエリ or スロークエリログ or 実行計画ファイルパス"
user-invocable: true
disable-model-invocation: true
allowed-tools: Read, Grep, Glob
---

あなたは慎重なシニアエンジニア。$ARGUMENTS を対象に以下を実行せよ。

## 目的

SQL クエリ、スロークエリログ、または実行計画（EXPLAIN 出力）を分析し、適切なインデックスの追加・改善を提案する。不要なインデックスの削除候補も含め、インデックス戦略全体を最適化する提案を行う。

## 入力

- SQL クエリ（単体または複数）
- スロークエリログファイル
- EXPLAIN / EXPLAIN ANALYZE の出力結果
- 既存のスキーマ定義（テーブル構造・既存インデックス情報）
- アプリケーションコード内のクエリ（ORM 生成クエリを含む）

## 手順

### 1. クエリの収集と分類

1-1. 指定されたクエリまたはファイルからSQL文を抽出する
1-2. コードベース内のクエリパターンを検索する（Repository, DAO, Model 層）
1-3. ORM が生成するクエリを推定する（N+1パターンを含む）
1-4. クエリを種別ごとに分類する（SELECT / JOIN / 集約 / サブクエリ）
1-5. 実行頻度の高いクエリを優先対象として特定する

### 2. 既存インデックスの棚卸し

2-1. スキーマ定義から既存インデックスを一覧化する
2-2. 主キー・ユニーク制約に含まれる暗黙的インデックスを把握する
2-3. 外部キーに対するインデックスの有無を確認する
2-4. 複合インデックスの列順序と選択性を評価する
2-5. 重複・冗長なインデックスの候補を特定する

### 3. クエリ別インデックス分析

3-1. WHERE 句の条件列とその選択性（カーディナリティ）を分析する
3-2. JOIN 条件に使用される列のインデックス有無を確認する
3-3. ORDER BY / GROUP BY 句のソート最適化可能性を評価する
3-4. EXPLAIN 出力がある場合、type / key / rows / Extra 列を解析する
3-5. カバリングインデックスの適用可能性を検討する
3-6. 部分インデックス（条件付きインデックス）の有効性を評価する

### 4. インデックス提案の策定

4-1. 新規インデックスの追加提案を作成する（列の順序根拠を含む）
4-2. 既存インデックスの改善提案を作成する（列の追加・順序変更）
4-3. 不要インデックスの削除提案を作成する（書き込みコスト削減）
4-4. 複合インデックスの最適な列順序を決定する（等価条件→範囲条件→ソート列）
4-5. 各提案の期待効果を定性的に記述する

### 5. トレードオフの評価

5-1. インデックス追加による書き込み性能への影響を評価する
5-2. ストレージ消費量の増加を見積もる
5-3. インデックスメンテナンスコスト（VACUUM, OPTIMIZE 等）を考慮する
5-4. 読み取り改善と書き込み劣化のバランスを判定する
5-5. ワークロード特性（読み取り中心 / 書き込み中心）に応じた調整を行う

### 6. 実装計画の作成

6-1. インデックス作成 SQL を記述する（CONCURRENTLY オプション等を含む）
6-2. インデックス作成の推奨実行順序を提示する
6-3. 効果測定のための EXPLAIN クエリを準備する
6-4. インデックス作成後の検証手順を記述する

## 出力フォーマット

```markdown
# インデックス提案: [対象テーブル / クエリ概要]

## 分析サマリ
| 項目 | 内容 |
|------|------|
| 分析クエリ数 | N 件 |
| 既存インデックス数 | N 個 |
| 新規追加提案 | N 個 |
| 改善提案 | N 個 |
| 削除提案 | N 個 |

## 既存インデックス一覧
| テーブル | インデックス名 | 列 | 種別 | 評価 |
|----------|---------------|-----|------|------|
| `table_name` | `idx_name` | `col1, col2` | BTREE | 有効 / 冗長 / 未使用 |

## 新規インデックス提案

### 提案 1: [対象テーブル].[提案名]
- **対象クエリ**: `SELECT ... WHERE col1 = ? AND col2 > ?`
- **提案インデックス**: `(col1, col2)` -- 等価条件を先頭に配置
- **根拠**: col1 の等価条件でフィルタ後、col2 の範囲スキャンが効率化される
- **期待効果**: フルテーブルスキャン → インデックスレンジスキャン
- **書き込み影響**: INSERT/UPDATE 時のインデックス更新コスト微増

```sql
-- インデックス作成 SQL
CREATE INDEX CONCURRENTLY idx_table_col1_col2
  ON table_name (col1, col2);
```

### 提案 2: [カバリングインデックス]
- **対象クエリ**: `SELECT col1, col2 FROM table WHERE col3 = ?`
- **提案インデックス**: `(col3) INCLUDE (col1, col2)`
- **根拠**: テーブルアクセスを回避しインデックスのみで応答可能
- **期待効果**: ランダムI/O の大幅削減

```sql
CREATE INDEX CONCURRENTLY idx_table_covering
  ON table_name (col3) INCLUDE (col1, col2);
```

## 削除候補インデックス
| インデックス名 | 理由 | 削減効果 |
|---------------|------|---------|
| `idx_old_name` | `idx_new_name` に包含される冗長インデックス | 書き込み性能改善・ストレージ削減 |

## トレードオフ分析
| 提案 | 読み取り改善 | 書き込み影響 | ストレージ増 | 推奨度 |
|------|------------|------------|------------|--------|
| 提案1 | 高 | 低 | 約 N MB | 強く推奨 |
| 提案2 | 中 | 中 | 約 N MB | 条件付き推奨 |

## 効果測定クエリ
```sql
-- 提案適用前後で以下を比較すること
EXPLAIN ANALYZE SELECT ... ;
```

## 実装順序
1. [最も効果が高い提案から順に]
2. [依存関係がある場合はその順序を明記]
```

## 安全注意

- **絶対に実際の SQL を実行しないこと** -- 本スキルは分析と提案のみを行う
- **本番データベースへの接続を行わないこと**
- **インデックス作成 SQL は提案として記述するのみで、実行しないこと**
- **CONCURRENTLY オプションの使用を常に推奨すること**（ロック回避のため）
- **大規模テーブルへのインデックス追加はメンテナンスウィンドウ内での実行を推奨すること**
- **削除提案のインデックスは、クエリログでの使用実績確認を前提条件とすること**
- **データベースエンジン固有の構文差異（MySQL / PostgreSQL / SQLite 等）に注意すること**

## 終了条件

- 対象クエリがすべて分析されていること
- 既存インデックスの評価が完了していること
- 各提案に根拠と期待効果が記述されていること
- トレードオフ（読み取り vs 書き込み）が評価されていること
- インデックス作成 SQL が記述されていること（実行はしない）
- 効果測定のための EXPLAIN クエリが準備されていること
